字符串匹配算法：共四种算法
共用基础概念：
	主串：被查找的字符串
	模式串：查找的字符串。在A字符串中查找B，A是主串，B是模式串。
一：Brute Force算法(BF蛮力算法)：
	算法思想：主串长度为n，模式串长度为m。在主串中查找模式串，只需要检查主串从0,1,2,3...n-m为起始位置的n-m+1个长度为m的字符串是否与模式串相等。
	最差时间复杂度为：O(n*m)，理论效率低。类似于主串“aaaaaaaaaa...aa”中查找模式串“aaaab”。
	备注：虽然时间复杂度比较高，但工程中使用较多，因为：1.实际使用中主串和模式串的长度比较短；中途匹配时，遇到不匹配的模式串就可以停止了，不需要把模式串中的每个字符都进行比对。2.思想简单，实现简单，符合KISS(Keep it Simple and Stupid)设计原则，简单不容易出错。
二：Rabin-Karp算法(RK算法，由Rabin和Karp发明)
	算法思想：是BF算法的升级，在长度为n的主串中查找长度为m的模式串，按照BF算法，只需要匹配n-m+1个长度为m的子串是否和模式串相等，BF算法比对子串和模式串是采用一个字符一个字符的比对，导致时间复杂度高。RK算法则巧妙的利用子串哈希值和模式串哈希值进行比对，哈希值的数字比对效率很快，故就很高了。	
	实现思路：主要复杂在了如何取子串的哈希值。思路一：采用进制的思路，一个字符串就是一个数字。查看主串的所有字符，看有多少种，如果有a-z种，则是26进制，比如"dbc"就是一个数字，数值=3*26^2+1*26^1+2*26^0。n-m+1个字符串，减少计算的复杂度：使用递推公式，用前一个推到出后一个字符串，可以减少计算；26^的计算可以放到数据中，指数次为数组的下表，值为26^。思路二：求字符的数值和，会出现哈希冲突，时间复杂度会提高一些。
	时间复杂：O(n)
三：Boyer Moore算法(BM算法)
	算法思想：基于BF算法的优化，BF算法中模式串在主串上滑动比较时，模式串一个字符一个字符的滑动，造成效率低。BM算法则寻找规律，多个字符串的滑动，跳过一些肯定不会匹配的地方。
	实现思路：使用坏字符规则和好后缀规则，取两个规则计算出滑动值的最大值作为模式串需要的滑动值，将模式串向后滑动。
						坏字符规则：BM算法中模式按照模式串的下标从大到小，倒着进行匹配。在匹配的过程中，滑动的个数=坏字符对应模式串的字符下标-坏字符在模式串的下标(模式串中不存在则为-1)，在模式串中查找坏字符，可以利用散列表进行快速查询。
						好后缀规则：预加载模式串的好后缀的两个数据，1.suffix[]记录后缀子串是否在模式串中存在，不存在为-1，存在为对应子串的起始下标。2.prefix[]当后缀子串和前缀子串相等时，值为true，否则为false。
												1.好后缀在模式串中存在。滑动值=滑动j(好后缀前一位的坏字符所在的下标)-好后缀在模式串中相匹配子串的起始下标(suffix[k])+1。
												2.好后缀在模式串中不存在，则计算出模式串的前缀子串和好后缀匹配的最长子串，进行滑动模式串。r是模式串的好后缀下标，取值为从j+2到m-1，如果prefix[r]=ture，则滑动r位，如果false则滑动m位。
  时间复杂度：BM算法内存占用三个数据，坏字符数据、suffix，prefix。效率高，O(n)。比较的次数上限可能是5n或者3n。
四：KMP算法(K/M/P为三个发明人名字)
	算法思想：模式串滑动比较主串时，基于好前缀的处理，一次性滑动多位，跳过肯定不会匹配的子串。
	实现思路：滑动值=坏字符所在模式串的下标-好前缀的的前缀子串的结尾字符的下标(next[i])。预加载next函数数组next[](失效函数)，next数组的下标为模式串中好前缀子串结尾字符的下标，数组值为好前缀子串的前缀子串与好前缀的后缀子串相等的结尾字符的下标。预加载时可以采用动态规划的思想，next[i-1]= k-1，如果b[k]和b[i]相等，则next[0,i]=k；如果不相等则求next[k-1] = x的值，看b[x+1]是否b[i]相等，如果相等next[i]=x+1，直到相等or求出-1为结束。
	时间复杂度：O(m+n)
	
	